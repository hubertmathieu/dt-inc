import bpy
import numpy as np
import math
from car import Car

# CONST
FRAME_RATE = bpy.context.scene.render.fps
EULER_X = math.radians(-90)
EULER_Y = math.radians(0)
EULER_Z = math.radians(-90)
MAX_DELTA = 0.5 / FRAME_RATE

# obj name
car_name = "body_high"
bille_name = "BILLE"

# GLOBAL
# car dimension
wheelbase_m = 1
tire_width_m = 1

last_distance = 0
obstacle_distance = 50
current_angle = EULER_Z
current_speed = 50

frame = 0 


def init_objects():
    # init ball position
    obj = bpy.data.objects[bille_name]
    obj.animation_data_clear()
    obj.location = (-1.93,0,1.102)

    # init car position
    obj = bpy.data.objects[car_name]
    obj.animation_data_clear()
    obj.location = (0,0,1)
    obj.rotation_euler = [EULER_X, EULER_Y, -current_angle]
    obj.keyframe_insert(data_path="rotation_euler", frame = 0)

    obj = bpy.data.objects[car_name]
    
    
def set_obj_location(obj, next_dist):
    obj.location.x += next_dist * np.sin(current_angle)
    obj.location.y += next_dist * np.cos(current_angle)
    obj.keyframe_insert(data_path="location", frame = frame + 1)
    
    
def set_obj_rotation(obj):
    obj.rotation_euler = [EULER_X, EULER_Y, -current_angle ]
    obj.keyframe_insert(data_path="rotation_euler", frame = frame + 1)
    

def steering_angle_to_global_angle(steering_angle):
    global current_angle

    if(steering_angle != 0):
        turning_radius_m = (wheelbase_m / np.sin(np.abs(steering_angle))) + (tire_width_m/2)
        turning_circumference_m = 2 * np.pi * turning_radius_m
        circle_traveled_ratio = last_distance / turning_circumference_m
        angle_traveled_r = circle_traveled_ratio*2*np.pi
        
        if (steering_angle < 0):
            current_angle += angle_traveled_r
        else:
            current_angle -= angle_traveled_r
            

def advance(steering_angle, should_stop=False):
    global last_distance
    global obstacle_distance
    
    obj = bpy.data.objects[car_name]
    steering_angle_to_global_angle(steering_angle)
    
    if (should_stop):
        next_dist = last_distance - MAX_DELTA
        next_dist = 0 if (next_dist <= 0) else next_dist 
            
    else :
        next_dist = current_speed / FRAME_RATE
        if (next_dist > last_distance + MAX_DELTA):
            next_dist = last_distance + MAX_DELTA
    
    obstacle_distance -= next_dist
    
    set_obj_location(obj, next_dist)
    set_obj_rotation(obj)
    
    
    last_distance = next_dist
    

def determine_stopping_dist(should_stop):
    if (obstacle_distance > 0 and last_distance > 0 and not should_stop):
            dist_to_stop = (last_distance ** 2) / (2*MAX_DELTA)
            should_stop = dist_to_stop > obstacle_distance 
            
    return should_stop
    
    
def loop():
    global frame
    global current_speed
    
    steering_angle = math.radians(8)
    should_stop = False
    
    while(frame != 2000 ):
        
        if (steering_angle == 0):
            should_stop = determine_stopping_dist(should_stop)
            
        else :
            if (frame > 150):
                should_stop = True
            
        advance(steering_angle, should_stop)
 
        frame+=1 
        

if __name__ == "__main__":
    init_objects()
    loop()