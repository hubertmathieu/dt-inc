import bpy
import numpy as np
import math

# CONST
STOP_TRSHOLD = 300
FRAME_RATE = bpy.context.scene.render.fps
EULER_X = math.radians(-90)
EULER_Y = math.radians(0)
EULER_Z = math.radians(-90)
MAX_DELTA = 0.5 / FRAME_RATE

# obj name
car_name = "body_high"
bille_name = "BILLE"

# GLOBAL
# car dimension
wheelbase_m = 1
tire_width_m = 1


last_distance = 0
current_angle = EULER_Z
current_speed = 400

frame = 0 


def init_objects():
    # init ball position
    obj = bpy.data.objects[bille_name]
    obj.animation_data_clear()
    obj.location = (-1.93,0,1.102)

    # init car position
    obj = bpy.data.objects[car_name]
    obj.animation_data_clear()
    obj.location = (0,0,1)
    obj.rotation_euler = [EULER_X, EULER_Y, -current_angle]
    obj.keyframe_insert(data_path="rotation_euler", frame = 0)

    obj = bpy.data.objects[car_name]
    
    
def set_obj_location(obj, next_dist):
    obj.location.x += next_dist * np.sin(current_angle)
    obj.location.y += next_dist * np.cos(current_angle)
    obj.keyframe_insert(data_path="location", frame = frame + 1)
    
    
def set_obj_rotation(obj):
    obj.rotation_euler = [EULER_X, EULER_Y, -current_angle ]
    obj.keyframe_insert(data_path="rotation_euler", frame = frame + 1)
    

def steering_angle_to_global_angle(steering_angle):
    global current_angle

    if(steering_angle != 0):
        turning_radius_m = (wheelbase_m / np.sin(np.abs(steering_angle))) + (tire_width_m/2)
        turning_circumference_m = 2 * np.pi * turning_radius_m
        circle_traveled_ratio = last_distance / turning_circumference_m
        angle_traveled_r = circle_traveled_ratio*2*np.pi
        
        if (steering_angle < 0):
            current_angle += angle_traveled_r
        else:
            current_angle -= angle_traveled_r
            

def advance(steering_angle, stop=False):
    global last_distance
    
    obj = bpy.data.objects[car_name]
    steering_angle_to_global_angle(steering_angle)
    
    if (stop):
        next_dist = last_distance - MAX_DELTA
        next_dist = 0 if (next_dist < 0) else next_dist 
            
    else :
        next_dist = current_speed / FRAME_RATE
        if (next_dist > last_distance + MAX_DELTA):
            next_dist = last_distance + MAX_DELTA
    
    set_obj_location(obj, next_dist)
    set_obj_rotation(obj)
    
    
    last_distance = next_dist
    
    
    
def loop():
    global frame
    global current_speed
    
    steering_angle = math.radians(5)
    
    while(frame != 2000):
        if (frame > 100 and current_speed > 0):
            advance(steering_angle, stop=1)
        else :
            advance(steering_angle)
        #decelerate(100)
 
        frame+=1 
        

if __name__ == "__main__":
    init_objects()
    loop()